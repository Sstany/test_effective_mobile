// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package gen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xZ227bxhb9FWJOHs5BSGtI3/nm3A6MEyRBnBygsVVjLI7kCXjLzDCw6hKIE7R9aICk",
	"P9Ci6AdUuRhx7Fr5hc0/KmYoW6RF2XLtyGkaPwgiOZp9mbXW3pveRI0oiKOQhlIgdxOJxjoNiP660Gpx",
	"2iKSReFdKhJfqpsxj2LKJaN6iYwk8VcbkdDP6AYJYp8i13YwNlHAQhYkAXKxiWQ7pshFLJS0RTlKUxNx",
	"+ihhnHrIXS7uUz9cHK09pA2JUhNd5ZRIupSsiQZnce7Qo4SKCo9o6K16RNKSP8h2LAc708hEYeL7ZE3d",
	"lDyhJoqJlJSHyEVf/xsv29Z8/Vt7GVtO/T+Wg1dWvE0nvYQOXRKSs7ClXIo5a5SNTJ0Us4kE5Y9Zg66G",
	"JDji4Fck9OiGccdPRJU1IQmXFXHh2YO4/mociaB8lXnlbWfwDLablFrOWtO2pmYd2yJ0pmnNzkzO0Nl5",
	"ghtrBJmoGfGASOSiJGHe4OZHzrgU/EEC+w6UgqwCwXXOI36XijgKBa04ePVYlOP4P/GZpwFsNAnzqeca",
	"fSPGOhEGCx+rNUYvlEF8HB9Tz2iVu0W0Dnrb0Ij2VkmZOEidpoVnLXv6no3dSexi/KCYaeW4JZnOIKfE",
	"ux367SGummPjQg6fo2g40b3PhkKx9/HPcnw8zbl4CrKaRTSX0lHFi/v68am1/OPp9vRZQJdH4xlL+YpT",
	"AW/ubMAbTV6PFVW1BwubkXLMowW5QnevL92zsi3Yzp7Aa9jJtgx4C3vZCwM68CZ7AtvwBjrZ97ADO+pJ",
	"B/ZhP/sx+86ALrxSH/uwBx14D/sWfIAuvIUPahfYhY5apG7tZc/hHXThNXSyp7ANe7AN71WYTOr8FCFy",
	"kF9j4c4iMtFjykXupz2BJ7DKchTTkMQMuWhyAk9M5lld1zCqicJO+k6LarQprOnqsOghF/2XyqXSQrUF",
	"JwGVVNWV5U3ElMVHCeVtJZ4aC0VG6M7pXAhaAMQysZoL1g1szdc351KreDl1mkt7CIaqozoCpqrQynIb",
	"kI2bNGzJdeQ609OaTwfX9tF4vlmwHmBrHjpW9gJeWvB79hNsraysrAj1YamPy/XLp/D2EOuDbubkJhs5",
	"uW2s/05qTYfkpKh4VRk5ayUZZvhQBqvN9uv5+Zr1WcBktU37aFILGbVHz2jUbAo6xMTAsZ1waHWlhnlv",
	"qCnuYKz7rCiUNNRsJ3Hss4bme+2hyJuyvmEmaaB/eInTJnLRv2r9uajWG4pqpZ4uPfSCcE7auZqWVfT2",
	"/9SqqVO6cpwH5Sa4wuQV4hkHBTU10fQ4bS+GCn7E12pNuaF/oAuVSIKA8DZyEfzaqwRd2DVKpaELu7pA",
	"94bJsjjficSAOvM8zCuR1z63GIdPmmm54KouJB3AnH1ujpShNpjr3FHvovE15Tjjs30/jHnUoEKoRtC4",
	"Hkom258qyLvwTvVF2dPseRnmu9kzvbrcldSEErYRO5OlJBitOSmVrDJ2i6L70crVuExWNWF/n55qPL3T",
	"WQvkcaQZfFP4pRiOpBMvy8NU9sLItrKn0IUd+AO6+vtORZUclI9N5qX5FOfTfNAsS8g1fb+kIoveEBFR",
	"g1Mftr13OcOIfHE0GwT01OAceysyrvaO+6IrZe7eeGzfiqRxI0pC79OE/W/wdgL2YGdIdTRHK4OfH4Dx",
	"2NrHixfjL3zo8+EX/TrsWfbDEEroG8biNT0fJVXjUfIZUuP8p7vh755Hmu4q6kvv/e8/l0xfBsBKRv8M",
	"r2Bfv9weVuTS3v8VDuhZNnIzahDfyJ8jEyXcRy5alzJ2azVfPVuPhHTn8BxGaT39MwAA///HYmZmxR8A",
	"AA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
